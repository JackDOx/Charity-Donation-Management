const oracledb = require('oracledb');
const { withOracleDB } = require('./userService');

async function fetchFundsFromDb() {
    return await withOracleDB(async (connection) => {
        const result = await connection.execute(`
            SELECT 
                f.ID AS FundID,
                f.Purpose,
                COALESCE(SUM(t.Amount), 0) AS TotalTransactions,
                CASE
                    WHEN indFund.ID IS NOT NULL THEN 'Individual Fund'
                    WHEN orgFund.ID IS NOT NULL THEN 'Organization Fund'
                    ELSE 'Unknown'
                END AS FundType
            FROM 
                Fund f
            LEFT JOIN 
                Transaction t ON f.ID = t.FundID
            LEFT JOIN 
                IndividualFund indFund ON f.ID = indFund.ID
            LEFT JOIN 
                OrganizationFund orgFund ON f.ID = orgFund.ID
            GROUP BY 
                f.ID, f.Purpose, indFund.ID, orgFund.ID
        `);
        return result.rows;
    }).catch(() => {
        return [];
    });
}

async function findTransactionsWithBalance(x) {
    return await withOracleDB(async (connection) => {
        const result = await connection.execute(`
            SELECT 
                f.ID AS FundID,
                f.Purpose,
                COALESCE(SUM(t.Amount), 0) AS TotalTransactions,
                CASE
                    WHEN indFund.ID IS NOT NULL THEN 'Individual Fund'
                    WHEN orgFund.ID IS NOT NULL THEN 'Organization Fund'
                    ELSE 'Unknown'
                END AS FundType
            FROM 
                Fund f
            LEFT JOIN 
                Transaction t ON f.ID = t.FundID
            LEFT JOIN 
                IndividualFund indFund ON f.ID = indFund.ID
            LEFT JOIN 
                OrganizationFund orgFund ON f.ID = orgFund.ID
            GROUP BY 
                f.ID, f.Purpose, indFund.ID, orgFund.ID
            HAVING
                COALESCE(SUM(t.Amount), 0) >= :minTransactionTotal
        `, {
            minTransactionTotal: x
        });
        return result.rows;
    }).catch(() => {
        return [];
    });
}



async function initiateFundsTable() {
    return await withOracleDB(async (connection) => {
        try {
            await connection.execute(`DROP TABLE Fund`);
        } catch (err) {
            console.log('Table might not exist, proceeding to create...');
        }

        const result = await connection.execute(`
            CREATE TABLE Fund (
                ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
                Purpose VARCHAR(255) NOT NULL,
                Balance NUMBER(10, 2) NOT NULL,
                Verification VARCHAR(255) NOT NULL,
                CONSTRAINT Unsigned_Balance CHECK (Balance >= 0)
            )
        `);
        return true;
    }).catch(() => {
        return false;
    });
}

async function insertFund(purpose, balance, verification) {
    return await withOracleDB(async (connection) => {
        try {
            const result = await connection.execute(
                `INSERT INTO Fund (Purpose, Balance, Verification ) VALUES (:purpose, :balance, :verification)`,
                [purpose, balance, verification],
                { autoCommit: true }
            );

            return result.rowsAffected && result.rowsAffected > 0;
        } catch (err) {
            if (err instanceof Error) {
                console.log(err.message);
            }
        }
    }).catch(() => {
        return false;
    });
}


async function internalInsertFund(purpose, balance, verification) {
    return await withOracleDB(async (connection) => {
        try {
            const result = await connection.execute(
                `INSERT INTO Fund (Purpose, Balance, Verification) VALUES (:purpose, :balance, :verification) RETURNING ID INTO :id`,
                {
                    purpose: purpose,
                    balance: balance,
                    verification: verification,
                    id: { dir: oracledb.BIND_OUT, type: oracledb.NUMBER }
                },
                { autoCommit: true }
            );

            // Return the generated ID
            return result.outBinds.id[0];
        } catch (err) {
            if (err instanceof Error) {
                console.log(err.message);
            }
        }
    }).catch(() => {
        return null;
    });
}

async function deleteFund(fundId) {
    return await withOracleDB(async (connection) => {
        const result = await connection.execute(
            `DELETE FROM Fund WHERE ID = :fundId`,
            [fundId],
            { autoCommit: true }
        );

        return result.rowsAffected && result.rowsAffected > 0;
    }).catch((error) => {
        console.error("An error occurred while deleting the fund:", error);
        return false;
    });
}


async function updateFundBalance(fundId, newBalance) {
    return await withOracleDB(async (connection) => {
        const result = await connection.execute(
            `UPDATE Fund SET Balance=:newBalance WHERE ID=:fundId`,
            [newBalance, fundId],
            { autoCommit: true }
        );

        return result.rowsAffected && result.rowsAffected > 0;
    }).catch(() => {
        return false;
    });
}

async function countFunds() {
    return await withOracleDB(async (connection) => {
        const result = await connection.execute('SELECT Count(*) FROM Fund');
        return result.rows[0][0];
    }).catch(() => {
        return -1;
    });
}

module.exports = {
    fetchFundsFromDb,
    initiateFundsTable,
    insertFund,
    updateFundBalance,
    countFunds,
    internalInsertFund,
    findTransactionsWithBalance,
    deleteFund
};
