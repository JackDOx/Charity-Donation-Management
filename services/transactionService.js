const oracledb = require('oracledb');
const loadEnvFile = require('../utils/envUtil');

const envVariables = loadEnvFile('./.env');

const { withOracleDB } = require('./userService'); // Assuming db.js contains your withOracleDB function

// ----------------------------------------------------------

async function fetchTransactionsFromDb() {
    return await withOracleDB(async (connection) => {
        const result = await connection.execute(
          `SELECT T.*,
          u.Email,
          u.Name 
          FROM Transaction T
          JOIN Users u ON u.Email = T.UserEmail`);
        return result.rows;
    }).catch(() => {
        return [];
    });
}

async function findUserTransaction(userEmail) {
  return await withOracleDB(async (connection) => {
      const result = await connection.execute(
        `SELECT T.ID, T.Amount, T.TransactionDate, T.Content,
        u.Email,
        u.Name 
        FROM Transaction T
        JOIN Users u ON u.Email = T.UserEmail
        WHERE T.UserEmail =:userEmail`,
      [userEmail]);
      return result.rows;
  }).catch(() => {
      return [];
  });
}

async function findUsersWithTransactionsInAllFunds() {
  return await withOracleDB(async (connection) => {
      const result = await connection.execute(`
          SELECT T.UserEmail
          FROM Transaction T
          GROUP BY T.UserEmail
          HAVING COUNT(DISTINCT T.FundID) = (SELECT COUNT(*) FROM Fund)
      `);
      return result.rows;
  }).catch((error) => {
      console.error("An error occurred while executing the query:", error);
      return [];
  });
}

async function findFundsAboveOverallAvg() {
  return await withOracleDB(async (connection) => {
      const result = await connection.execute(`
          SELECT FundID, AVG(Amount) AS AvgAmount
          FROM Transaction
          GROUP BY FundID
          HAVING AVG(Amount) > (SELECT AVG(Amount) FROM Transaction)
      `);
      return result.rows;
  }).catch((error) => {
      console.error("An error occurred while executing the query:", error);
      return [];
  });
}

module.exports = {
  findFundsAboveOverallAvg
};



async function initiateTransactionsTable() {
    return await withOracleDB(async (connection) => {
        try {
            await connection.execute(`DROP TABLE Transaction`);
        } catch (err) {
            console.log('Table might not exist, proceeding to create...');
        }

        const result = await connection.execute(`
            CREATE TABLE Transaction (
                ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
                Amount DECIMAL(10, 2) NOT NULL,
                TransactionDate DATE NOT NULL,
                Content VARCHAR(255) NOT NULL,
                UserEmail VARCHAR(255),
                FundID INTEGER NOT NULL,
                OrganizationEmail VARCHAR(255),
                CONSTRAINT Unsigned_Amount CHECK (Amount >= 0),
                CONSTRAINT Tran_Fund FOREIGN KEY (FundID) REFERENCES Fund(ID),
                CONSTRAINT Tran_User FOREIGN KEY (UserEmail) REFERENCES Users(Email) ON DELETE CASCADE,
                CONSTRAINT Tran_Org FOREIGN KEY (OrganizationEmail) REFERENCES VolunteerOrganization(Email) ON DELETE CASCADE,
                CONSTRAINT Tran_Participation CHECK (
                    (UserEmail IS NOT NULL AND OrganizationEmail IS NULL) OR
                    (UserEmail IS NULL AND OrganizationEmail IS NOT NULL))
            )
        `);
        return true;
    }).catch(() => {
        return false;
    });
}

async function insertTransaction(amount, transactionDate, content, userEmail, fundID, organizationEmail) {
    return await withOracleDB(async (connection) => {
        try {
            const result = await connection.execute(
                `INSERT INTO Transaction (Amount, TransactionDate, Content, UserEmail, FundID, OrganizationEmail) VALUES (:amount, TO_DATE(:transactionDate, 'YYYY-MM-DD'), :content, :userEmail, :fundID, :organizationEmail)`,
                [amount, transactionDate, content, userEmail, fundID, organizationEmail],
                { autoCommit: true }
            );

            return result.rowsAffected && result.rowsAffected > 0;
        } catch (err) {
            if (err instanceof Error) {
                console.log(err.message);
            }
        }
    }).catch(() => {
        return false;
    });
}

async function updateTransaction(id, amount, transactionDate, content, userEmail, fundID, organizationEmail) {
    return await withOracleDB(async (connection) => {
        const result = await connection.execute(
            `UPDATE Transaction SET Amount=:amount, TransactionDate=:transactionDate, Content=:content, UserEmail=:userEmail, FundID=:fundID, OrganizationEmail=:organizationEmail WHERE ID=:id`,
            [amount, transactionDate, content, userEmail, fundID, organizationEmail, id],
            { autoCommit: true }
        );

        return result.rowsAffected && result.rowsAffected > 0;
    }).catch(() => {
        return false;
    });
}

async function countTransactions() {
    return await withOracleDB(async (connection) => {
        const result = await connection.execute('SELECT Count(*) FROM Transaction');
        return result.rows[0][0];
    }).catch(() => {
        return -1;
    });
}

module.exports = {
    fetchTransactionsFromDb,
    initiateTransactionsTable,
    insertTransaction,
    updateTransaction,
    countTransactions,
    findUserTransaction,
    findUsersWithTransactionsInAllFunds,
    findFundsAboveOverallAvg
};
